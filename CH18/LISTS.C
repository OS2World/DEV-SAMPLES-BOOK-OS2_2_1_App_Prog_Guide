/*
* This file was generated by the SOM Compiler.
* FileName: lists.c.
* Generated using:
*     SOM Precompiler spc: 1.22
*     SOM Emitter emitc: 1.24
*/

#define lists_Class_Source
#include "lists.ih"

/*
 *                  Adds an item to the list
 */

/* All subclasses must override this method */
SOM_Scope INT   SOMLINK AddItem(lists *somSelf,
        PVOID *pItem)
{
    listsData *somThis = listsGetData(somSelf);
    listsMethodDebug("lists","AddItem");

    return (INT) 0;
}

/*
 *                   Removes the current item from
 *                   the list and returns it
 */

SOM_Scope PVOID   SOMLINK GetItem(lists *somSelf)
{
    PVOID      retItem = NULL;
    pListItem  pSaveItem;

    listsData *somThis = listsGetData(somSelf);
    listsMethodDebug("lists","GetItem");

    do {
       /* Error if the list is empty            */
       if (_bListEmptyFlag == LIST_IS_EMPTY) {
          break;
       }

       /* Copy the item from head of the chain   */
       /* Allocate return buffer   */
       retItem = (PVOID) SOMMalloc( _usListItemSize);
       if (!retItem) {
          break;
       }
       memcpy(retItem, &_pListHead->cData, _usListItemSize);

       /* Remove the item from the list  */
       /* Cases: 1 item in the list      */
       /*        > 1 item in the list    */

       if (_pListHead == _pListTail) {
          /* Only one item in the list */
          _pListHead = _pListTail = (pListItem)  NULL;
          _bListEmptyFlag = LIST_IS_EMPTY;
       } else {
          _pListHead = _pListHead->pNext;
          _pListHead->pPrev = (pListItem) NULL;
       }

       /* Now free the list item itself */
       SOMFree(pSaveItem);

    } while (0 ); /* enddo */

    return retItem;
}

/*
 *                   Add to head or tail of list
 */

SOM_Scope INT   SOMLINK AddPos(lists *somSelf,
       PVOID *pItem,
       UCHAR pos)
{
    pListItem   pNewItem;
    INT         rc = 0;

    listsData *somThis = listsGetData(somSelf);
    listsMethodDebug("lists","AddPos");

    do {
          /* Allocate space for a new ListItem   */
       pNewItem = SOMMalloc(sizeof(ListItem)-sizeof(UCHAR) +
                _usListItemSize);
       if (!pNewItem) {
          rc = MEMORY_ERROR;
          break;
       }

          /* Initialize the new Item */
       memcpy(&pNewItem->cData, pItem, _usListItemSize);
       pNewItem->pNext = (pListItem) NULL;
       pNewItem->pPrev = (pListItem) NULL;


       if (_bListEmptyFlag == LIST_IS_EMPTY) {
          _pListHead = _pListTail = pNewItem;
          _bListEmptyFlag = LIST_NOT_EMPTY;
          break;
       }

       if (pos == 'H') {
          /* Add the new Item to the head of the List */
          pNewItem->pNext = _pListHead;
          _pListHead = pNewItem;
       } else {
          /* Add the new Item to the end of the List */
          _pListTail->pNext = pNewItem;
          _pListTail = pNewItem;
       } /* endif */

    } while (0); /* enddo */

    return rc;
}

SOM_Scope void   SOMLINK somInit(lists *somSelf)
{
    listsData *somThis = listsGetData(somSelf);
    listsMethodDebug("lists","somInit");

    parent_somInit(somSelf);

    _pListHead = _pListTail = (pListItem) NULL;
    _usListItemSize = 1;
    _bListEmptyFlag = LIST_IS_EMPTY;
}

SOM_Scope void   SOMLINK somUninit(lists *somSelf)
{
    listsData *somThis = listsGetData(somSelf);
    listsMethodDebug("lists","somUninit");

    while (_bListEmptyFlag != LIST_IS_EMPTY) {
       _GetItem(somSelf);
    } /* endwhile */

    parent_somUninit(somSelf);
 }
